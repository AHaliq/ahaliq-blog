<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/circletype@2.3.0/dist/circletype.min.js"></script>
    <script src="https://kit.fontawesome.com/fa2321cbaa.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
    <style>
        :root {
            --fg-col: #333333;
            --fg-rgb: 51, 51, 51;
            --bg-col: #e6e6e6;
            --bg-rgb: 230, 230, 230;
            --fg2-col: #704b53;
            --fg2-rgb: 93, 73, 84;
        }

        ::selection {
            color: var(--bg-col);
            background: var(--fg2-col);
        }

        a {
            text-decoration: none;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            color: var(--fg-col);
        }

        body {
            display: flex;
            flex-direction: column;
            font-family: 'Helvetica', 'Arial', sans-serif;
        }

        #bg {
            position: fixed;
            z-index: -2;
            width: 100%;
            height: 100%;
            background-color: var(--bg-col);
        }

        #vcontainer {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-container {
            display: flex;
            position: fixed;
            width: 100%;
            justify-content: space-between;
            align-items: flex-start;
        }

        #socials-container {
            display: flex;
            gap: 2rem;
            margin: 2rem;
        }

        #circ {
            padding: 0.5rem;
            color: var(--fg2-col);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.25rem;
            animation: spin 25s linear infinite;
            user-select: none;
        }

        .colr {
            color: var(--fg2-col);
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        #blog-btn {
            text-transform: uppercase;
            font-weight: bold;
            margin: 2rem;
            padding-bottom: 0.5rem;
            border-bottom: 0.3rem solid var(--fg-col);
            transition: 0.3s;
            user-select: none;
            cursor: pointer;
        }

        .social-btn {
            color: var(--fg2-col);
            background-color: var(--bg-col);
            user-select: none;
            width: fit-content;
            padding: 0.5rem;
            border-radius: 2rem;
            transition: 0.3s;
            cursor: pointer;
        }

        .social-btn:hover {
            background-color: var(--fg2-col);
            color: var(--bg-col);
        }

        .social-btn>i {
            display: none;
        }


        #blog-btn:hover {
            padding-bottom: 0.1rem;
        }

        #mid-gap {
            height: 2rem;
        }

        #bot-gap {
            flex-grow: 1;
        }

        #bot-container {
            width: 100%;
            padding-top: 35vh;
            display: flex;
            flex-direction: column;
        }

        #hero {
            padding-left: 15%;
            font-weight: bold;
            font-size: 2.5rem;
            width: 20rem;
            padding-bottom: 2rem;
        }

        #brief {
            font-style: italic;
            padding-left: 15%;
            width: 30rem;
            padding-bottom: 100vh;
        }

        #down-btn {
            padding-top: 0rem;
            transition: 0.1s;
            cursor: pointer;
        }

        #down-btn:hover {
            padding-top: 1rem;
        }

        #about-section {
            background-color: rgba(var(--bg-rgb), 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-right: 15%;
            padding-left: 15%;
            padding-top: 1rem;
            padding-bottom: 1rem;
            margin-bottom: 18vh;
        }

        #about-title {
            text-transform: uppercase;
            font-weight: bold;
            font-size: 1.25rem;
            padding-bottom: 2rem;
        }

        #about-text {
            max-width: 45vw;
            min-width: 25rem;
        }

        #bot-blog-btn {
            margin-left: 15%;
            font-weight: bold;
            width: fit-content;
            font-size: 1.25rem;
            padding-bottom: 0.5rem;
            border-bottom: 0.3rem solid var(--fg-col);
            transition: 0.3s;
            user-select: none;
            cursor: pointer;
        }

        #bot-blog-btn:hover {
            padding-bottom: 0.1rem;
            margin-bottom: 0.4rem;
        }

        #bot-gap {
            height: 10vh;
        }

        .canvas {
            z-index: -1;
            position: fixed;
            right: 0;
        }

        @media only screen and (min-width: 1000px) {
            #about-section {
                background: none;
                padding-right: 600px;
                margin-bottom: 10vh;
            }
        }

        @media only screen and (min-width: 1200px) {
            .canvas {
                right: 15vw;
            }

            #about-section {
                padding-right: calc(15vw + 600px);
            }
        }

        @media only screen and (max-width: 600px) {
            #hero {
                font-size: 1.5rem;
                width: 12rem;
            }

            #brief {
                width: 17rem;
            }

            #about-text {
                min-width: 75vw;
            }

            #socials-container {
                gap: 0.1rem;
                margin-left: 0;
                margin-right: 0;
                align-items: center;
            }

            .btn-text {
                display: none;
            }

            .social-btn>i {
                display: block;
            }

            #about-section {
                padding-right: 15%;
                margin-bottom: 2rem;
            }

            .canvas {
                left: 50%;
                top: 50% !important;
                transform: translate(-50%, -50%);
                width: 100vw !important;
                height: 100vw !important;
            }
        }
    </style>
</head>

<body>
    <div id="bg"></div>
    <div id="vcontainer">
        <div id="top-container">
            <div id="circ">abdul•haliq•</div>
            <div id="socials-container">
                <a href="https://twitter.com/ahaliq_" target="_blank" class="social-btn" id="twitter">
                    <div class="btn-text">twitter</div>
                    <i class="fab fa-twitter fa-lg"></i>
                </a>
                <a href="https://github.com/AHaliq" target="_blank" class="social-btn" id="github">
                    <div class="btn-text">github</div>
                    <i class="fab fa-github fa-lg"></i>
                </a>
                <a href="https://www.linkedin.com/in/ahaliq/" target="_blank" class="social-btn" id="linkedin">
                    <div class="btn-text">linkedin</div>
                    <i class="fab fa-linkedin fa-lg"></i>
                </a>
            </div>
            <div id="blog-btn">blog</div>
        </div>
        <div id="bot-container">
            <div id="hero">
                Software Engineer, aspiring <span class="colr">PL</span> theorist
            </div>
            <div id="brief">
                Welcome to my blog site where I discuss pure math, logic and programming language theory!
                <div id="mid-gap"></div>
                <i onClick="scrollToBottom()" id="down-btn" class="fas fa-chevron-down fa-2x"></i>
            </div>
            <div id="about-section">
                <div id="about-title">about</div>
                <div id="about-text">
                    <p>
                        I’m a Computer Science graduate from National University of Singapore with a focus area in
                        Programming Languages. I’m a software engineer and researcher with interests in the field of
                        type
                        theory, logic and category theory.
                    </p>
                    <p>
                        I got into research intially from my exposure to haskell, and from there I was introduced to all
                        of
                        the mathematical theory behind the language.
                    </p>
                    <p>
                        What caught my attention the most at that point in time was homotopy type theory. I then began
                        researching other related fields.
                    </p>
                    <p>
                        On the engineering end, I familiarized myself with formal verification, model checkers and
                        theorem
                        provers, where I now apply in profession as a researcher at SMU’s Centre for Computational Law.
                    </p>
                    <p>
                        I have experience working with compilers for programming languages in CCLAW and in Zilliqa’s
                        smart
                        contract language.
                    </p>
                </div>
            </div>
            <div id="bot-blog-btn">read my blog</div>
            <div id="bot-gap"></div>
        </div>
    </div>
    <script>
        const ele = document.getElementById('circ');
        const circtxt = new CircleType(ele);
        ele.style.width = circtxt._radius * 2 + "px"
        // setup circle spinner logo

        const fg2 = getComputedStyle(document.documentElement).getPropertyValue('--fg2-col');
        const fg1 = getComputedStyle(document.documentElement).getPropertyValue('--fg-col');
        const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg-col');
        const bgrgb = getComputedStyle(document.documentElement).getPropertyValue('--bg-rgb');
        const bgrgbarr = bgrgb.split(',').map(x => parseInt(x.trim()));
        let fg, fgb, hi;
        // capture color variables

        const wdt = 600;
        const hgt = 600;
        // p5js canvas dimensions

        function scrollToBottom() {
            window.scrollTo({ left: 0, top: document.body.scrollHeight, behavior: "smooth" });
        }

        function scrollPercent(elm) {
            var p = elm.parentNode
            return (elm.scrollTop || p.scrollTop) / (p.scrollHeight - p.clientHeight) * 100
        }

        function repositionCanvas(e) {
            const yp = scrollPercent(document.body);
            const cele = document.querySelector(".canvas");
            const pad = 0.4;
            if (document.documentElement.clientWidth < 600) {
                if (yp < 14) {
                    cele.style.opacity = 0;
                } else if (yp < 35) {
                    cele.style.opacity = (yp - 14) / (35 - 14);
                } else if (yp < 70) {
                    cele.style.opacity = 1 - (yp - 35) / (70 - 35);
                } else {
                    cele.style.opacity = 0;
                }
            } else {
                cele.style.opacity = 1;
                cele.style.top = Math.round((document.documentElement.clientHeight - hgt) * (yp * 0.01 * (1 - pad * 2) + pad)) + "px";
            }
        }
        // dom event functions 

        const virtualmsg = 'this is a virtual function, inherit this class and implement it';
        class ModuloShape {
            constructor(x, y, r, n, m, { w = 0.2, bw = 1, dw = 4, c = fg, dc = hi, dp = 0, xs = 3, aw = 170, af = 28, fv = 0.08 } = {}) {
                this.x = x;     // center x coordinate
                this.y = y;     // center y coordinate
                this.r = r;     // radius of shape
                this.n = n;     // number of points
                this.m = m;     // modular arithmetic multiplier
                this.w = w;     // weight of line
                this.bw = bw;   // weight of shape base line
                this.dw = dw;   // scales w for deviant
                this.c = c;     // colour
                this.dc = dc;   // deviant colour
                this.dp = dp;   // deviant probability
                this.aw = aw;   // animation wait time
                this.af = af;   // animation fade out time
                this.fv = fv;   // fade value
                this.xs = xs;   // number of pixels to extend fade out square size
                this.tlx = x - r - xs;      // top left corner's x
                this.tly = y - r - xs;      // top left corner's y
                this.s = r * 2 + xs + xs;   // fade out square side size
                this.pts;                   // list of points around shape
                this.fi = 1 - fv;           // fade inverse '1 - fv'
                this.fc = color(...bgrgbarr, round(fv * 255)); // fade color
                // constants

                this.tp = 0;    // animation phase variable
                this.t = 0;     // timer variable
                // variables

                this.calculatePoints();
                // initialize pts
            }

            /**
             * returns list of 'n' points distributed around shape
             * must 'n' values to 'this.pts'
             */
            calculatePoints() {
                throw virtualmsg;
            }

            /**
             * draws base shape
             */
            drawBase() {
                throw virtualmsg;
            }

            drawLine(a, b) {
                const isD = random(1) < this.dp;
                strokeWeight(this.w * (isD ? this.dw : 1));
                stroke(isD ? this.dc : this.c);
                line(...this.pts[a % this.n], ...this.pts[b % this.n]);
            }

            anim() {
                switch (this.tp) {
                    case 0:
                        this.drawLine(this.t, this.t * this.m);
                        this.t++;
                        if (this.t === this.n) {
                            this.tp = 1;
                            this.t = this.aw;
                        }
                        return 0;
                    case 1:
                        if (this.t > 0) {
                            this.t--;
                        } else {
                            this.tp = 2;
                            this.t = this.af;
                        }
                        return 1;
                    case 2:
                        if (this.t > 0) {
                            this.t--;
                        } else {
                            this.tp = 3;
                        }
                        noStroke();
                        fill(this.fc);
                        square(this.tlx, this.tly, this.s);
                        return 1;
                    case 3:
                        noStroke();
                        fill(bg);
                        square(this.tlx, this.tly, this.s);
                        this.tp = 4;
                        return 2;
                    case 4:
                        return 2;
                }
            }
        }

        class ModuloCircle extends ModuloShape {
            constructor(...args) {
                super(...args);
            }

            calculatePoints() {
                this.pts = [...Array(this.n).keys()]
                    .map(i => TWO_PI / this.n * i)
                    .map(a => [this.x + cos(a) * this.r, this.y + sin(a) * this.r]);
            }

            drawBase() {
                strokeWeight(this.bw);
                stroke(this.c);
                noFill();
                circle(this.x, this.y, this.r * 2);
            }
        }

        class ModuloSquare extends ModuloShape {
            constructor(...args) {
                super(...args);
            }

            calculatePoints() {
                this.ns = ceil(this.n / 4);
                this.n = this.ns * 4;
                const step = (this.r * 2) / (this.ns + 1);
                const spts = [...Array(this.ns).keys()].map(x => x * step);
                const rs = spts.map(x => [this.x + this.r, this.y - this.r + x]);
                const bs = spts.map(x => [this.x + this.r - x, this.y + this.r]);
                const ls = spts.map(x => [this.x - this.r, this.y + this.r - x]);
                const ts = spts.map(x => [this.x - this.r + x, this.y - this.r]);
                this.pts = [...rs, ...bs, ...ls, ...ts];
            }

            drawBase() {
                strokeWeight(this.bw);
                stroke(this.c);
                noFill();
                square(this.tlx, this.tly, this.r * 2);
            }
        }

        class ModuloTriangle extends ModuloShape {
            constructor(...args) {
                super(...args);
            }

            calculatePoints() {
                this.ns = ceil(this.n / 3);
                this.n = this.ns * 3;
                const fac = 1; // 2 / (2 * sqrt(3))
                const rfac = this.r * fac;
                const stepfx = (this.r * 2) / (this.ns + 1);
                const stepx = this.r / (this.ns + 1);
                const stepy = (rfac * 2) / (this.ns + 1);
                const spts = [...Array(this.ns).keys()];
                const rs = spts.map(x => [this.x + stepx * x, this.y - rfac + stepy * x]);
                const bs = spts.map(x => [this.x + this.r - stepfx * x, this.y + rfac]);
                const ls = spts.map(x => [this.x - this.r + stepx * x, this.y + rfac - stepy * x]);
                this.pts = [...rs, ...bs, ...ls];
            }

            drawBase() {
                const fac = 1; // 2 / (2 * sqrt(3))
                const rfac = this.r * fac;
                strokeWeight(this.bw);
                stroke(this.c);
                noFill();
                line(this.x, this.y - rfac, this.x + this.r, this.y + rfac);
                line(this.x + this.r, this.y + rfac, this.x - this.r, this.y + rfac);
                line(this.x - this.r, this.y + rfac, this.x, this.y - rfac);
            }
        }
        // p5js functions

        class DynamicGrid {
            constructor(x, y, s, n, p, g, pad = 0.9, pts = 200, dev = 0.1, dp = 0) {
                this.x = x; // top left of grid
                this.y = y; // top left of grid
                this.s = s; // side of one smallest cell
                this.n = n; // number of cells along length
                this.p = p; // number of simultaneous draws
                this.g = g; // probability of cell growing
                this.pad = pad;         // percent of smallest cell as padding
                this.pts = pts;         // number of points for shapes
                this.dev = dev;         // number of points to deviate for shapes
                this.dp = dp;           // shape deviant probability
                this.padw = pad * s;    // pad actual length

                this.shapes = [];
                this.clears = [];
                this.grid = [...Array(n).keys()].map(x => [...Array(n).keys()].map(x => false));
                this.occ = [];
                this.fre = [...Array(n * n).keys()];
                this.tot = n * n;

                this.dead = false;
                this.testvar = 0;
            }

            coordToKey(x, y) {
                return y * this.n + x;
            }

            keyToCoord(k) {
                const y = floor(k / this.n);
                return [k - (y * this.n), y];
            }

            getFreeKey() {
                let k = this.fre[floor(random(0, this.fre.length))];
                return k;
            }

            setCell(x, y) {
                const k = this.coordToKey(x, y);
                this.fre = this.fre.filter(x => x !== k);
                this.occ.push(k);
                this.grid[y][x] = true;
            }

            unsetCell(x, y) {
                const k = this.coordToKey(x, y);
                this.occ = this.occ.filter(x => x != k);
                this.fre.push(k);
                this.grid[y][x] = false;
            }

            getCellsFromRange(tlx, tly, brx, bry) {
                let rs = [];
                for (let i = tlx; i <= brx; i++) {
                    for (let j = tly; j <= bry; j++) {
                        rs.push([i, j]);
                    }
                }
                return rs;
            }

            expand(tlx, tly, brx, bry) {
                let len = brx - tlx + 1;
                let ls = [...Array(len).keys()];
                let tw = !ls.map(w => this.grid?.[tly - 1]?.[tlx + w] ?? true).every(b => !b);
                let lw = !ls.map(w => this.grid?.[tly + w]?.[tlx - 1] ?? true).every(b => !b);
                let rw = !ls.map(w => this.grid?.[tly + w]?.[brx + 1] ?? true).every(b => !b);
                let bw = !ls.map(w => this.grid?.[bry + 1]?.[tlx + w] ?? true).every(b => !b);
                let cs = [
                    (this.grid?.[tly - 1]?.[tlx - 1] ?? true) || tw || lw,
                    (this.grid?.[tly - 1]?.[brx + 1] ?? true) || tw || rw,
                    (this.grid?.[bry + 1]?.[brx + 1] ?? true) || bw || rw,
                    (this.grid?.[bry + 1]?.[tlx - 1] ?? true) || bw || lw
                ].map((b, i) => [i, b]).filter(([i, b]) => !b).map(([i, b]) => i);
                // get all valid expand choices

                if (cs.length === 0) return [true, [tlx, tly], [brx, bry]];
                // if no choices, return as is

                let c = cs[floor(random(0, cs.length))];
                // make a choice

                switch (c) {
                    case 0: tlx--; tly--; break;
                    case 1: tly--; brx++; break;
                    case 2: brx++; bry++; break;
                    default: tlx--; bry++;
                }
                // expand

                return [false, [tlx, tly], [brx, bry]];
            }

            makeShape() {
                if (this.occ.length >= this.tot) return; // terminate if no empty cells
                let k = this.getFreeKey();
                let tl = this.keyToCoord(k);
                let br = [...tl];
                let brk = true;
                // step1 : find random empty cell

                while (random(1) < this.g) {
                    [brk, tl, br] = this.expand(...tl, ...br);
                    if (brk) break;
                }
                let cells = this.getCellsFromRange(...tl, ...br);
                cells.forEach(x => this.setCell(...x));
                // step2 : expand cell

                let x = (tl[0] + br[0]) / 2;
                let y = (tl[1] + br[1]) / 2;
                x = this.x + (x + 0.5) * this.s;
                y = this.y + (y + 0.5) * this.s;
                let r = (br[0] - tl[0] + 1 - ((1 - this.pad) * 2)) * this.s;
                // step3 : calculate shape data

                const nn = this.pts * this.dev;
                const N = round(random(this.pts - nn, this.pts + nn));
                const M = round(random(2, N));
                const c = lerpColor(fg, fgb, random(0, 1));
                const rnd = random(1);
                const f = ModuloCircle;//rnd < 0.8 ? ModuloCircle : rnd < 0.95 ? ModuloSquare : ModuloTriangle;
                const shape = new f(x, y, r / 2, N, M, { c: c, dp: this.dp });
                this.shapes.push([shape, () => cells.forEach(x => this.unsetCell(...x))]);
                // step4 : make shape
            }

            print() {
                console.log(this.grid.map(a => a.map(b => b ? '*' : '-').join('')).join('\n'));
            }

            kill() {
                this.dead = true;
            }

            isEmpty() {
                return this.occ.length === 0;
            }

            anim() {
                let [cp, a] = this.shapes.reduce(([cp, a], [s, c]) => {
                    let res = s.anim();
                    switch (res) {
                        case 0: return [cp + 1, [...a, [s, c]]];
                        case 1: return [cp, [...a, [s, c]]];
                        default: c(); return [cp, a];
                    }
                }, [0, []]);
                this.shapes = a;
                if (cp < this.p && !this.dead) this.makeShape();
            }
        }

        class StaticGrid {
            constructor(n = 3, nm = 5, pad = 0.9, pts = 200, dev = 0.1, dp = 0) {
                this.n = n;
                this.nm = nm;
                this.pad = pad;
                this.pts = pts;
                this.dev = dev;
                this.dp = dp;
                this.shapes = [];
            }

            newGrid(sze = 200) {
                const mulwdt = Math.floor(wdt / sze);
                const mulhgt = Math.floor(hgt / sze);
                return [...Array(mulwdt * mulhgt).keys()]
                    .map(i => [i, i % mulwdt * sze + sze * 0.5, Math.floor(i / mulwdt) * sze + sze * 0.5])
                    .map(([i, x, y]) => {
                        const nn = this.pts * this.dev;
                        const N = round(random(this.pts - nn, this.pts + nn));
                        const M = round(random(2, N));
                        const c = lerpColor(fg, fgb, random(0, 1));
                        const r = random(1);
                        const f = ModuloCircle;//random([ModuloCircle, ModuloSquare, ModuloTriangle]);
                        const circ = new f(x, y, (sze * 0.5) * this.pad, N, M, { c: c, dp: this.dp });
                        return circ;
                    });
            }

            kill() {
                this.dead = true;
            }

            isEmpty() {
                return this.shapes.length === 0;
            }

            anim() {
                if (this.isEmpty() && !this.dead) {
                    this.shapes = this.newGrid(wdt / round(random(this.n, this.nm)));
                } else {
                    this.shapes = this.shapes.filter(x => x.anim() < 2);
                }
            }
        }

        // automaters

        let canvas;
        let grid;
        let tmr, maxTmr;
        let dyn = false;
        function reset(dyn = false) {
            grid = dyn ? new DynamicGrid(0, 0, wdt / 9, 9, 9, 0.7, 0.97, 400) : new StaticGrid(2, 5, 0.97, 400);
            tmr = 0;
            maxTmr = round(random(1000, 2000));
        }
        function setup() {
            fg = color(fg2);
            fgb = color(fg1);
            hi = fg;
            // setup color constants

            canvas = createCanvas(wdt, hgt);
            document.addEventListener('scroll', repositionCanvas);
            window.onresize = repositionCanvas;
            canvas.addClass("canvas");
            repositionCanvas();
            // setup dom with canvas

            reset();
        }

        function draw() {
            grid.anim();
            if (tmr < maxTmr) tmr++;
            else if (grid.isEmpty()) {
                dyn = !dyn;
                reset(dyn);
            } else {
                grid.kill();
            }
        }
    </script>
</body>

</html>